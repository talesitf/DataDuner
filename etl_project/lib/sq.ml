let ( let* ) = Lwt.bind
let ( let*? ) = Lwt_result.bind

(* The helper function `iter_queries` sequentially schedules a list of queries.
   Each query is a function that takes the
   connection handle of the database as an argument. *)
let iter_queries queries connection =
  List.fold_left
    (fun a f ->
      Lwt_result.bind a (fun () -> f connection))
    (Lwt.return (Ok ()))
    queries

(* The `%rapper` node here makes `ppx_rapper` generate code, such that, when applying
  the `create_employees_table () connection` function,
  the provided SQL `CREATE` query will be run without any parameters and without
  receiving any data from the database.

  In case of successful execution of the query, we get back an `Ok ()` value, otherwise
  we get an `Error` value.
  *)
let create_employees_table =
  [%rapper
    execute {sql| CREATE TABLE employees
              (name VARCHAR,
              firstname VARCHAR,
              age INTEGER)
            |sql}
  ]

(* Table creation for order totals *)
let create_order_totals_table =
  [%rapper
    execute {sql| CREATE TABLE IF NOT EXISTS order_totals (
              order_id INTEGER PRIMARY KEY,
              total_amount REAL,
              total_tax REAL)
            |sql}
  ]

(* Table creation for monthly means *)
let create_monthly_means_table =
  [%rapper
    execute {sql| CREATE TABLE IF NOT EXISTS monthly_means (
              year_month INTEGER PRIMARY KEY,
              year INTEGER,
              month INTEGER,
              avg_amount REAL,
              avg_tax REAL)
            |sql}
  ]

type employee =
  { name:string; firstname:string; age:int }
let employees = [
  {name = "Dupont"; firstname = "Jacques"; age = 36};
  {name = "Legendre"; firstname = "Patrick"; age = 42}
  ]

(* For the SQL `INSERT` query, `ppx_rapper` generates a function `insert_employee (p: employee) connection`.
  The tag `record_in` tag tells `ppx_rapper` to read the values `name`, `firstname`,
  and `age` from the provided record value, while the `%[TYPE_NAME]{[INPUT_FIELD_NAME]}` notation specifies
  which conversions to perform on the input values. *)
let insert_employee =
  [%rapper
    execute
    {sql| INSERT INTO employees VALUES
        (%string{name},
        %string{firstname},
        %int{age})
    |sql}
    record_in
  ]

(* Insert order total record *)
type order_total = {
  order_id: int;
  total_amount: float;
  total_tax: float;
}

let insert_order_total =
  [%rapper
    execute
    {sql| INSERT INTO order_totals VALUES (
        %int{order_id},
        %float{total_amount},
        %float{total_tax}
    ) |sql}
    record_in
  ]

(* Insert monthly mean record *)
type monthly_mean = {
  year_month: int;
  year: int;
  month: int;
  avg_amount: float;
  avg_tax: float;
}

let insert_monthly_mean =
  [%rapper
    execute
    {sql| INSERT INTO monthly_means VALUES (
        %int{year_month},
        %int{year},
        %int{month},
        %float{avg_amount},
        %float{avg_tax}
    ) |sql}
    record_in
  ]

(* The `get_many` tag makes `ppx_rapper` generate code that queries the database and
   receives a list of values. The `record_out` tag specifies that each list item
   will be a record.

   The `@[TYPE_NAME]{[COLUMN_NAME]}` notation specifies
   which conversions to perform on the output values.
   *)
let get_all_employees =
  [%rapper
    get_many
    {sql|SELECT
        @string{name},
        @string{firstname},
        @int{age}
      FROM employees
    |sql}
    record_out
  ]

(* Here's another example query that selects a single row via the SQL `WHERE` clause, using the `get_opt` tag.
   This query has both input (`name`) and output values (`name`, `firstname`, `age`).

   Here the absence of the `record_in` tag makes `ppx_rapper` generate code where the
   input values are passed as named arguments.
   The `get_opt` tag means that the result will be an option: `None` if no rows matching the criteria
    is found, and `Some r` if a row match the criteria.
   *)
let get_employee_by_name =
  [%rapper
    get_opt
    {sql|SELECT
        @string{name},
        @string{firstname},
        @int{age}
      FROM employees
      WHERE name=%string{name}
    |sql}
    record_out
  ]

(* Read all order totals from database *)
let get_all_order_totals =
  [%rapper
    get_many
    {sql|SELECT
        @int{order_id},
        @float{total_amount},
        @float{total_tax}
      FROM order_totals
      ORDER BY order_id
    |sql}
    record_out
  ]

(* Read all monthly means from database *)
let get_all_monthly_means =
  [%rapper
    get_many
    {sql|SELECT
        @int{year_month},
        @int{year},
        @int{month},
        @float{avg_amount},
        @float{avg_tax}
      FROM monthly_means
      ORDER BY year_month
    |sql}
    record_out
  ]

(* All query functions generated by `ppx_rapper` take an argument and a `connection` parameter.
The function `insert_employee` must be called with
a value of type `employee` and `connection`. To insert multiple records from
a list, we use `List.map` to create a list
of functions. Each of these functions will execute its
associated query when called. The function `iter_queries` runs
the queries in sequence.

Note that, if you have to insert many records, it makes sense to perform a bulk insert query instead. *)
let execute_queries connection =
  let*? () = create_employees_table () connection in
  let*? () =
    iter_queries
      (List.map insert_employee employees)
      connection
  in
  let*? employees = get_all_employees () connection in
  employees |> List.iter (fun employees ->
    Printf.printf
      "name=%s, firstname=%s, age=%d\n"
      employees.name
      employees.firstname
      employees.age);
  let*? employees =
    get_employee_by_name ~name:"Dupont" connection
  in
  match employees with
  | Some employees' ->
    Printf.printf
      "found:name=%s, firstname=%s, age=%d\n"
      employees'.name
      employees'.firstname
      employees'.age;
    Lwt_result.return ()
  | None ->
    print_string "Not found";
    Lwt_result.return ()

(* Initialize database and save data *)
let save_data order_totals monthly_means connection =
  (* Create tables if they don't exist *)
  let*? () = create_order_totals_table () connection in
  let*? () = create_monthly_means_table () connection in
  
  (* Insert order totals *)
  let*? () =
    iter_queries
      (List.map insert_order_total order_totals)
      connection
  in
  
  (* Insert monthly means *)
  let*? () =
    iter_queries
      (List.map insert_monthly_mean monthly_means)
      connection
  in
  
  Lwt_result.return ()

(* Function to read and display all stored data *)
let read_data connection =
  (* Read order totals *)
  let*? order_totals = get_all_order_totals () connection in
  Printf.printf "\n===== Stored Order Totals =====\n";
  List.iter (fun record ->
    Printf.printf "Order ID: %d\n" record.order_id;
    Printf.printf "  Total Amount: %.2f, Total Tax: %.2f\n" 
      record.total_amount record.total_tax
  ) order_totals;
  
  (* Read monthly means *)
  let*? monthly_means = get_all_monthly_means () connection in
  Printf.printf "\n===== Stored Monthly Means =====\n";
  List.iter (fun record ->
    Printf.printf "Period: %04d-%02d\n" record.year record.month;
    Printf.printf "  Avg Amount: %.2f, Avg Tax: %.2f\n" 
      record.avg_amount record.avg_tax
  ) monthly_means;
  
  Lwt_result.return ()

(* The main program starts by establishing an Lwt environment.
   The function `with_connection` opens the database,
   executes a function with the `connection` database handle,
   and closes the database connection again, even when an exception is raised. *)


